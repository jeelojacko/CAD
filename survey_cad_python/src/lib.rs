use pyo3::prelude::*;
use survey_cad::geometry::Point as CadPoint;
use survey_cad::surveying::{station_distance as cad_station_distance, Station};

#[pyclass]
#[derive(Clone)]
pub struct Point {
    inner: CadPoint,
}

#[pymethods]
impl Point {
    #[new]
    pub fn new(x: f64, y: f64) -> Self {
        Self { inner: CadPoint::new(x, y) }
    }

    #[getter]
    fn x(&self) -> f64 {
        self.inner.x
    }

    #[setter]
    fn set_x(&mut self, value: f64) {
        self.inner.x = value;
    }

    #[getter]
    fn y(&self) -> f64 {
        self.inner.y
    }

    #[setter]
    fn set_y(&mut self, value: f64) {
        self.inner.y = value;
    }
}

#[pyfunction]
fn station_distance(a: &Point, b: &Point) -> f64 {
    let sa = Station::new("a", a.inner);
    let sb = Station::new("b", b.inner);
    cad_station_distance(&sa, &sb)
}

#[pymodule]
fn survey_cad_python(_py: Python<'_>, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Point>()?;
    m.add_function(wrap_pyfunction!(station_distance, m)?)?;
    Ok(())
}

/// Initialize the `survey_cad_python` module when embedding Python.
///
/// This simply forwards to the `survey_cad_python` function generated by the
/// `#[pymodule]` macro above, allowing other crates to easily register the
/// module with an embedded Python interpreter.
pub fn init(py: Python<'_>, m: &Bound<'_, PyModule>) -> PyResult<()> {
    survey_cad_python(py, m)
}
